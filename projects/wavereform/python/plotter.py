
from icecube.wavereform import refold_pulses, chi_squared
from icecube.icetray import I3ConditionalModule, I3Module, I3Units
from icecube.dataclasses import I3Waveform, I3RecoPulseSeriesMap
import numpy
import pylab
import itertools
from matplotlib.colors import hsv_to_rgb
from collections import defaultdict

class HoboStatus(object):
	def __init__(self, start, stop, status=I3Waveform.VIRGINAL):
		self.interval = (start, stop)
		self.status = status
	@classmethod
	def fromStatusCompound(cls, stat):
		return cls(stat.interval[0], stat.interval[1], stat.status)
	@classmethod
	def inflate(cls, wf):
		stati = wf.waveform_information
		expanded = []
		j = 0
		i = 0
		while i < len(wf.waveform):
			if j < len(stati) and i < stati[j].interval[0]:
				stat = cls(i, stati[j].interval[0])
				expanded.append(stat)
				i = stati[j].interval[0]
			elif j < len(stati) and i == stati[j].interval[0]:
				expanded.append(cls.fromStatusCompound(stati[j]))
				i = stati[j].interval[1]
				j += 1
			elif j == len(stati):
				stat = cls(i, len(wf.waveform))
				expanded.append(stat)
				break
		return expanded
		
def clip_path(edges, bins, slice_):

	npoints = 2*(slice_.stop-slice_.start+1)
	
	# Starting and stopping spans get one point fewer.
	if (slice_.start == 0 or slice_.stop == len(bins)) and slice_.stop-slice_.start < len(bins):
		npoints -= 1
	
	x = numpy.zeros(npoints, numpy.float)
	y = numpy.zeros(npoints, numpy.float)
		
	if slice_.start == 0 and slice_.stop == len(bins):
		# complete span
		x[0::2], x[1::2] = edges, edges
		y[1:-1:2], y[2::2] = bins, bins
	elif slice_.start == 0:
		# starting span
		x[0:-1:2], x[1::2] = edges[slice_], edges[slice_]
		x[-1] = edges[slice_.stop]
		y[1::2] = bins[slice_]
		y[2::2] = bins[slice_]
	elif slice_.stop == len(bins):
		# ending span
		sl = slice(slice_.start+1, slice_.stop+1)
		x[0] = edges[slice_.start]
		x[1::2], x[2::2] = edges[sl], edges[sl]
		y[0:-1:2] = bins[slice_]
		y[1::2]   = bins[slice_]
	else:
		# interior span
		sl = slice(slice_.start, slice_.stop+1)
		x[::2], x[1::2] = edges[sl], edges[sl]
		y[1:-1:2] = bins[slice_]
		y[2::2] = bins[slice_]
		
		y[0] = bins[slice_.start-1]
		y[-1] = bins[slice_.stop]
	
	return x, y

class ShowPlots(I3Module):
	"""
	Show plots generated by previous instances of WaveformPlotter with
	Block=False.
	"""
	def __init__(self, ctx):
		I3Module.__init__(self, ctx)
		self.AddParameter('DisplayPlots', 'Whether or not to display plots on screen', False)
		self.AddParameter('SavePlots', 'Whether or not to save plots to png files', True)
		self.AddParameter('OutFilename', 'Filename to use for the plot if saving as png', 'test.png')
		self.AddOutBox("OutBox")

	def Configure(self):
		self.display_plots = self.GetParameter('DisplayPlots')
		self.save_plots = self.GetParameter('SavePlots')
		self.out_filename = self.GetParameter('OutFilename')

	def DAQ(self, frame):
		if self.display_plots:
			pylab.show()
		if self.save_plots:
			pylab.savefig(self.out_filename)
		self.PushFrame(frame)

class WaveformPlotter(I3ConditionalModule):
	def __init__(self, ctx=None):
		I3ConditionalModule.__init__(self, ctx)
		
		self.AddParameter('Launches', 'Name of DOMLaunches in the frame', None)
		self.AddParameter('Waveforms', 'Name of calibrated waveforms in the frame', 'CalibratedWaveforms')
		self.AddParameter('Errata', 'Time windows in which calibration should be considered fishy', [])
		self.AddParameter('ShowChiSquared', '', True)
		self.AddParameter('Pulses', 'Name of pulses in the frame', 'WavedeformPulses')
		self.AddParameter('Block', 'Stop to display plots at every frame', True)
		self.AddParameter('UseDOMsimulatorTemplates', 'Use pulse shapes from simulation', False)
		
		self.AddOutBox("OutBox")
		
	def Configure(self):
		
		self.launchname = self.GetParameter('Launches')
		self.wfname = self.GetParameter('Waveforms')
		self.errata = self.GetParameter('Errata')
		self.show_chi2 = self.GetParameter('ShowChiSquared')
		self.pulsename = self.GetParameter('Pulses')
		self.block = self.GetParameter('Block')
		self.use_domsimulator_hacks = self.GetParameter('UseDOMsimulatorTemplates')
	
	@staticmethod
	def plot_wf(ax, wf, **kwargs):
		times = wf.time + wf.bin_width*numpy.arange(0, len(wf.waveform)+1)
		trace = numpy.array(wf.waveform)
		kwargs['ls'] = 'steps'
		times /= I3Units.microsecond
		trace /= I3Units.mV
		
		valid = []
		clipped = []
		for stat in HoboStatus.inflate(wf):
			if stat.status == wf.VIRGINAL:
				valid.append(stat.interval)
			else:
				clipped.append(stat.interval)
				
		for rng in valid:
			x, y = clip_path(times, trace, slice(*rng))
			kwargs['ls'] = '-'
			ax.plot(x, y, **kwargs)
			kwargs['label'] = '__nolabel__'
			
		for rng in clipped:
			x, y = clip_path(times, trace, slice(*rng))
			kwargs['ls'] = ':'
			ax.plot(x, y, **kwargs)
	
	@staticmethod
	def plot_pulses(ax, trange, wf, pulses, cal, stat, use_domsimulator_hacks=False, **kwargs):

		times = numpy.arange(trange[0], trange[1], 0.25)
		# shift times by half a digitizer bin so that the plotted
		# points cross through the center of the bin
		half_shift = wf.bin_width/2.
		
		trace = refold_pulses(pulses, wf.digitizer, wf.channel,
		    cal, stat, times, use_domsimulator_hacks)
		
		ax.plot((times-half_shift)/I3Units.microsecond, trace/I3Units.mV, **kwargs)
	
	@staticmethod
	def plot_exclusions(ax, trange, windows, **kwargs):
		import matplotlib.transforms as mtransforms
		from matplotlib.patches import Rectangle
		# Specify x in data coords and y in axis coords
		trans = mtransforms.blended_transform_factory(ax.transData, ax.transAxes)		
		
		for w in windows:
			rect = Rectangle((w.start/I3Units.microsecond, 0), (w.stop-w.start)/I3Units.microsecond, 1,
			    edgecolor=None, alpha=0.3, transform=trans, **kwargs)
			ax.add_patch(rect)
			kwargs.pop('label', None)
	
	@staticmethod
	def get_time_range(wfs):
		tstart, tend = numpy.inf, -numpy.inf
		for wf in wfs:
			if wf.time < tstart:
				tstart = wf.time
			end_time = wf.time + wf.bin_width*len(wf.waveform)
			if end_time > tend:
				tend = end_time
		
		return tstart, tend
		
	def DAQ(self, frame):
		wfname = self.wfname
		pulsename = self.pulsename

		if pulsename in frame:
			pulsemap = I3RecoPulseSeriesMap.from_frame(frame, pulsename)
		else:
			pulsemap = None

		if self.launchname is not None and self.launchname in frame:
			launches = frame[self.launchname]
		else:
			launches = None
		
		calib = frame['I3Calibration']
		status = frame['I3DetectorStatus']
		errata = dict()
		for k in self.errata:
			if k in frame:
				errata[k] = frame[k]
		
		wfsm = frame[wfname]
		for om, wfs in wfsm.items():
			
			cal = calib.dom_cal[om]
			stat = status.dom_status[om]
			
			if pulsemap and om in pulsemap:
				pulses = pulsemap[om]
			else:
				pulses = None
			
			atwds = defaultdict(list)
			fadcs = []
			
			# organize or channels
			for wf in wfs:
				if wf.digitizer is I3Waveform.ATWD:
					atwds[wf.channel].append(wf)
				elif wf.digitizer is I3Waveform.FADC:
					fadcs.append(wf)
			
			fig = pylab.figure(figsize=(8,4))
			fig.subplots_adjust(left=0.1, bottom=0.12, right=0.96, top=0.90)
			ax = pylab.gca()
			
			trange = self.get_time_range(wfs)
			
			colors = itertools.cycle([ 'b', 'r',      'g',      'goldenrod'])
			pcolors = itertools.cycle(['c', 'orange', 'indigo', 'deeppink'])
			pcolors = itertools.cycle(['b', 'r',      'g',      'goldenrod'])
			
			wfs = fadcs
			label = 'FADC'
			color = next(colors)
			for wf in wfs:
				self.plot_wf(ax, wf, color=color, label=label)
				label='__nolabel__'
			
			for channel in range(len(atwds)):
				wfs = atwds[channel]
				label = 'ATWD%d' % channel
				color = next(colors)
				
				for wf in wfs:
					self.plot_wf(ax, wf, color=color, label=label)
					label = '__nolabel__'
			
			if pulses:
				for wfs in [fadcs] + [atwds[i] for i in range(len(atwds))]:
					if len(wfs) == 0:
						continue
					pcolor = next(pcolors)
					if self.show_chi2:
						chi2 = 0; nterms = 0
						for wf in wfs:
							c, n = chi_squared(pulses, wf, cal, stat)
							chi2 += c
							nterms += n
						label = 'chi2 = %.1f' % (chi2/nterms)
					else:
						label = '__nolabel__'
					self.plot_pulses(ax, trange, wfs[0], pulses, cal, stat,
					    use_domsimulator_hacks=self.use_domsimulator_hacks,
					    color=pcolor, label=label)
			
			
			for c, k in zip(('b', 'r'), errata):
				if om in errata[k]:
					windows = errata[k][om]
					self.plot_exclusions(ax, trange, windows, color=c, label=k)
					
			pylab.grid()
			pylab.ylabel('ADC voltage [-mV]')
			pylab.xlabel('Time [microseconds]')
			pylab.legend(prop=dict(size='small'), ncol=2)
			title = ('OM(%d,%d) %s' % (om.string, om.om, wfname))
			if pulses:
				qtot = sum([pulse.charge for pulse in pulses])
				title += ('/%s: %.1f PE' % (pulsename, qtot))
			pylab.title(title, size='small')

		if launches is not None:
			for om in wfsm.keys():
				figure = pylab.figure(figsize=(8,4))
				dls = [dl for dl in launches[om] if dl.lc_bit]
				for i, dl in enumerate(dls):
					ax = pylab.subplot(1,len(dls),i+1)
					pylab.plot(dl.raw_fadc, ls='steps')
					for atwd in dl.raw_atwd:
						if len(atwd) > 0:
							pylab.plot(atwd, ls='steps')
				pylab.title(str(om))
		
		if self.block:	
			pylab.show()

		self.PushFrame(frame)
